# A valid snippet should starts with:
#
#		snippet trigger_word [ "description" [ options ] ]
#
# and end with:
#
#		endsnippet
#
# Snippet options:
#
#		b - Beginning of line.
#		i - In-word expansion.
#		w - Word boundary.
#		r - Regular expression
#		e - Custom context snippet
#		A - Snippet will be triggered automatically, when condition matches.
#
# Basic example:
#
#		snippet emitter "emitter properties" b
#		private readonly ${1} = new Emitter<$2>()
#		public readonly ${1/^_(.*)/$1/}: Event<$2> = this.$1.event
#		endsnippet
#
# Online reference: https://github.com/SirVer/ultisnips/blob/master/doc/UltiSnips.txt
snippet test "Sample spec test"
it('should render', () => {
  
});
endsnippet

snippet fc "function component"
export const ${1:foo}: React.FC<${3}> = ({ ${2} }) => {
  return <div>${4}</div>;
};
endsnippet

snippet usecb "useCallback"
const ${1} = useCallback(() => {
  
}, []);
endsnippet

snippet usest "useState"
const [${1}, ${2}] = useState();
endsnippet

snippet useref "useRef"
const ${1} = useRef<HTMLDivElement | null>(null);
endsnippet

snippet useef "useEffect"
useEffect(() => {
  ${1}
}, [${2}]);
endsnippet

snippet usememo "useMemo"
useMemo(() => {
  ${1}
}, [${2}]);
endsnippet

snippet tapLog "consoleTap"
const taplog = (f: Function, s: string) => (...args: unknown[]) => {
  console.log(">>> " + s + ">>>", ...args);
  return f(...args);
};
endsnippet

snippet logg "log console and return"
const logg = <T extends unknown>(x:T, ...rest) => {
  console.log(x, ...rest);
  return x;
};
endsnippet

snippet range "range sequance generator"
const range: {
  (stop: number): number[];
  (start: number, stop: number, step?: number): number[];
} = (start: number, stop?: number, step: number = 1) =>
  Array.from(
    { length: stop === undefined ? start : (stop - start) / step + 1 },
    (_, i) => (stop === undefined ? 0 : start) + i * step
  );
endsnippet

snippet swap "swaps two elements in array"
const swap = <T extends unknown>(a: number, b: number, arr: T[]): T[] => {
  const temp = arr[a];
  arr[a] = arr[b];
  arr[b] = temp;
  return arr;
};
endsnippet

snippet times "call the fn X times"
const times = <T extends unknown>(f: () => T, t: number) => {
  let result: T;
  while (t--) {
    result = f();
  }
  return result;
};
endsnippet

snippet mapObj "get new object by mapping the values of an object"
  const map = (obj, f) =>
    Object.fromEntries(Object.entries(obj).map(([k, v]) => f(k, v)));
endsnippet

snippet sortNums "pure sort numbers"
const sortNums = (
  arr: Array<number>,
  f = (a: number, b: number) => (a - b > 0 ? 1 : -1)
) => arr.slice(0).sort(f);
endsnippet

snippet sortBy "Sorts an array by selector fn" b
const sortBy = <T>(fn: (item: T) => any, array: T[]): T[] =>
  array.slice(0).sort((a, b) => (fn(a) > fn(b) ? 1 : -1));
endsnippet

snippet longestSeq "longest sequence of x in array/string"
const longestSeq = <T extends unknown>(x: T, arr: Array<T> | string) => {
  let count = 0;
  let max = 0;
  for (let i = 0; i < arr.length; i++) {
    console.log({i,x,v:arr[i], count})
    if (arr[i] === x) {
      count++;
    } else {
      count = 0;
    }
    if (count > max) {
      max = count;
    }
  }
  return max;
};
endsnippet

snippet clamp "limits a number in between two others"
const clamp = (num: number, min: number, max: number) =>
  Math.min(Math.max(num, min), max);
endsnippet

snippet isBetween "check if a number is between two others"
export const isBetween = (min: number, max: number, x: number) =>
  min <= x && x < max;
endsnippet

snippet shiftRotate "rotates an array x times"
const arrayRotate = <T extends unknown>(x: number, arr: T[]) => {
  arr = arr.slice(0)
  x -= arr.length * Math.floor(x / arr.length);
  arr.push.apply(arr, arr.splice(0, x));
  return arr;
};
endsnippet

snippet symmetric "the symmetric difference of two sets, also known as the disjunctive union"
const symmetricDifference = <T extends unknown>(
  setA: Iterable<T>,
  setB: Iterable<T>
) => {
  let diff = new Set(setA);
  for (let elem of setB) {
    if (diff.has(elem)) {
      diff.delete(elem);
    } else {
      diff.add(elem);
    }
  }
  return [...diff];
};
endsnippet

snippet countBy "counts how many times a value returns the same result from a fn"
// if Object.fromEntries is not supported just return a map and deal with it
const countBy = <T extends unknown>(arr: T[], f = (x: T) => x) =>
  Object.fromEntries(
    arr.reduce((m, x) => {
      const prop = f(x);
      if (!m.has(prop)) {
        m.set(prop, 1);
      } else {
        m.set(prop, m.get(prop) + 1);
      }

      return m;
    }, new Map<T, number>())
  );
endsnippet

snippet evolve "proccess an object with a transformer object that has the same signature and transforming functions as values" b
const evolve = <
  O extends { [k: string]: unknown },
  T extends { [P in keyof O]?: (t: T[P]) => any },
  R extends { [K in keyof O]: ReturnType<T[K]> }
>(
  transformations: T,
  object: O
) => {
  const result = {} as R;

  for (const key in object) {
    const transformation = transformations[key];
    const type = typeof transformation;
    result[key] =
      type === "function"
        ? transformation(object[key])
        : transformation && type === "object"
        ? evolve(transformation, object[key])
        : object[key];
  }
  return result;
};
endsnippet

snippet binary "Binnary search a sorted array to find an index of target"
const binaryIndexOf = <T>(
  arr: Array<T>,
  target: T,
  left = 0,
  right = arr.length
): number => {
  const mid = Math.floor((right + left) / 2);
  const current = arr[mid];
  if (current === target) {
    return mid;
  }
  if (left === mid) {
    return -1;
  }

  if (current < target) {
    return binaryIndexOf(arr, target, mid, right);
  } else {
    return binaryIndexOf(arr, target, left, mid);
  }
};
endsnippet

snippet chunk "Devide array into chunks with batchSize (paginate)"
const chunk = <T>(arr: Array<T>, batchSize: number) =>
  Array.from({ length: Math.ceil(arr.length / batchSize) }, (_v, idx) =>
    arr.slice(idx * batchSize, (idx + 1) * batchSize)
  );
endsnippet

snippet curry "Curry a function"
const curry =
  (f) =>
  (...args) =>
    f.length <= args.length ? f(...args) : curry(f.bind(null, ...args));
endsnippet

snippet reverseArgs "Reverses (swaps) the arguments order"
const reverseArgs =
  (f) =>
  (...args) =>
    f(...args.slice(0).reverse());
endsnippet

snippet powerSet "Creates the power set of an array (array of sub-arrays)"
const powerSet = <T extends unknown>(arr: Array<T>) => {
  const result = [];
  for (let index = 0; index < Math.pow(2, arr.length); index++) {
    result.push(arr.filter((x, i) => index & (1 << i)));
  }
  return result;
};
endsnippet

snippet isAnagram "Checks if two string are annagram of each other"
const isAnagram = (a: string, b: string) => {
  const mapa = a
    .split('')
    .reduce(
      (m, c) => m.set(c, m.has(c) ? m.get(c)! + 1 : 1),
      new Map<string, number>()
    );
  const mapb = b
    .split('')
    .reduce(
      (m, c) => m.set(c, m.has(c) ? m.get(c)! + 1 : 1),
      new Map<string, number>()
    );
  if (mapa.size !== mapb.size) return false;
  for (const [k, v] of mapa) {
    if (mapb.get(k) !== v) {
      return false;
    }
  }
  return true;
};
endsnippet

snippet treeToArray "converts a { val, left, right } object like tree to array"
const treeToArray = (root) => {
  if (!root) return [];
  let res = [];
  const dfs = (node) => {
    if (!node) return;
    res.push(node.val);
    dfs(node.left);
    dfs(node.right);
  };
  dfs(root);
  return res;
};
endsnippet

snippet arrayToTree "converts an array to a { val, left, right  } object-like tree "
const arrayToTree = (arr) => {
  if (!arr || !arr.length) return null;
  const root = { val: arr[0] };
  const dfs = (node, i) => {
    if (!node) return;
    const leftIndex = 2 * i + 1;
    const rightIndex = 2 * i + 2;
    if (leftIndex < arr.length) node.left = { val: arr[leftIndex] };
    if (rightIndex < arr.length) node.right = { val: arr[rightIndex] };
    dfs(node.left, leftIndex);
    dfs(node.right, rightIndex);
  };
  dfs(root, 0);
  return root;
};
endsnippet

snippet updatePath "updates or sets a path" b
const updatePath = (obj, path: Array<stirng | number>, value: any) => {
  if (!obj || !path) return obj;
  const dfs = (node, path) => {
    if (!node) return;
    const key = path.shift();
    if (path.length === 0) {
      node[key] = value;
      return;
    } else if (node[key] === undefined) {
      node[key] = {};
    }
    dfs(node[key], path);
  };
  // avoid mutating the original path
  dfs(obj, path.slice(0));
  return obj;
};
endsnippet

snippet setRandomInterval "setInterval-like function that uses various timeout amount fixed between a range" b
const setRandomInterval = (
  intervalFunction: Function,
  minDelay: number,
  maxDelay: number
) => {
  let timeout: number;

  const runInterval = () => {
    const timeoutFunction = () => {
      intervalFunction();
      runInterval();
    };

    const delay =
      Math.floor(Math.random() * (maxDelay - minDelay + 1)) + minDelay;

    timeout = setTimeout(timeoutFunction, delay);
  };

  runInterval();

  return () => {
    clearTimeout(timeout);
  };
};
endsnippet

snippet groupBy "groupBy that returns an array of tuples and sorts them naturally" b
const groupBy = <T,>(fn: (a: T) => unknown, list: T[]) =>
  [
    ...list.reduce((m, x) => {
      const key = fn(x);
      if (m.has(key)) {
        m.get(key).push(x);
      } else {
        m.set(key, [x]);
      }
      return m;
    }, new Map()),
  ].sort(([a], [b]) =>
    String(a).localeCompare(String(b), undefined, {
      numeric: true,
      sensitivity: 'base',
    })
  );
endsnippet

snippet averageBy "returns the average value from a projection of a list" b
const averageBy = <T,>(fn: (a: T) => number, list: T[]) => {
  const filtered = list.filter(x => typeof fn(x) === 'number').map(fn);
  return filtered.reduce((a, b) => a + b, 0) / filtered.length;
};
endsnippet

snippet weightedAverage "returns the weighted average value from a projection of a list" b
const weightedAverage = <T,>(
  fn: (a: T) => number,
  weightFn: (a: T) => number,
  list: T[]
) => {
  const filtered = list.filter(x => typeof fn(x) === 'number');
  const weights = filtered.map(weightFn);
  const values = filtered.map(fn);
  const sum = weights.reduce((a, b) => a + b, 0);
  const weightedValues = values.map((v, i) => v * weights[i]);
  return weightedValues.reduce((a, b) => a + b, 0) / sum;
};
endsnippet
